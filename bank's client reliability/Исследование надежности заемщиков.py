#!/usr/bin/env python
# coding: utf-8

# # Исследование надёжности заёмщиков

# ## Описание проекта
# 
# 

# Заказчик — кредитный отдел банка. 
# 
# Цель исследования: выяснить **влияет ли семейное положение и количество детей клиента на факт погашения кредита в срок**. 
# 
# Входные данные от банка — статистика о платёжеспособности клиентов.
# 
# Результаты исследования будут учтены при построении модели кредитного скоринга — специальной системы, которая оценивает способность потенциального заёмщика вернуть кредит банку.

# ## Обзор данных

# In[1]:


# Импортирую необходимые библиотеки и открываю датасэт 
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import warnings
warnings.simplefilter("ignore")
try:
    df = pd.read_csv('C:\practicum\data.csv')
except:
    df = pd.read_csv('/datasets/data.csv')
    


# In[2]:


#Основная информация о датасэте 
print('information')
display(df.info())
print('description')
display(df.describe())


# В таблице 12 столбцов. В стобцах три типа данных: float64, int64, object  
# В столбцах days_employed, total_income имеются пропуски.  
# Проблем со стилем в названиях нет. 
# 
# Описание данных
# * children — количество детей в семье
# * days_employed — общий трудовой стаж в днях
# * dob_years — возраст клиента в годах
# * education — уровень образования клиента
# * education_id — идентификатор уровня образования
# * family_status — семейное положение
# * family_status_id — идентификатор семейного положения
# * gender — пол клиента
# * income_type — тип занятости
# * debt — имел ли задолженность по возврату кредитов
# * total_income — ежемесячный доход
# * purpose — цель получения кредита
# 
# 

# Странные данные в столбце с трудовым стажем (среднее значение 63 000 дней)

# In[3]:


#Обзор датасэта
df.head(10)


# #### Первичные выводы
# 1. В данных имеются отрицательные и невероятно большие значения в трудовом стаже (думаю, что это может быть связано с ошибкой в программе) 
# 2. Пропуски в столбцах days_employed и total_income в одних и тех же строках.

# ## Предобработка данных 

# In[4]:


#Пропуски 
df.isna().sum()


# Всего строк 21525, пропущенных значений 2174, доля пропущенных значений 10%

# In[5]:


df[df.isna().any(axis=1)].head()


# Пропуски есть только в колонках со стажем и доходом в одних и тех же строках. Думаю они связаны.  
# Думаю, надо заменить пропуски на медианные значения, что большие цифры не так сильно влияли 

# По хорошему за объянением странностей в датасэте необходимо было бы обратиться к источнику этих данных. Но тк такой возможности нет, то придется воспольховаться логикой и интуицией.
# 
# Тк в стаже отрицательные значение невозможны, то **преобразуем из и возьмем значение по модулю**

# In[6]:


#Преобразование отрицательных значение в положительные 
df['days_employed'] = abs(df['days_employed'])


# In[7]:


#Функция для описания значений в колонке 
def description(column):
    print('min', column.min())
    print('max', column.max())
    print('mean', column.mean())
    print('median', column.median())
    


# In[8]:


#Характеристика опыта работы 
description(df['days_employed'])
display(df.nlargest(5, 'days_employed'))
display(df.nsmallest(5, 'days_employed'))


# Самые большие числа выглядят совсем нереалистичными, больше похоже на "Минут" устроен. 
# Самые маленькие числа тоже выглядят нереалистичными, больше похоже на выбросы или на ошибки в программе.  
# Причем медианные значение 2200 дней (6 лет), а среднее 67000 (7 000 лет), значит, гигантских значений не сильно много
# На первый вгляд, есть взаимосвязь больших значений опыта работы со статусом "пенсионер"

# In[9]:


#Гистограмма "Опыт работы"
sns.histplot(data=df, x = 'days_employed', bins=30,  kde=True)


# По этой гистограмме видно, что в данных два пика. Реалистичный (до 50000 дней) нереалистичный, скорее всего связанный с ошибкой при сборе данных

# In[10]:


# % нереальных значений от датасэта 
print(df.query('days_employed > 17500').count() /  len(df))


# In[11]:


# Гистограмма реалистичной части 
sns.histplot(data=df.query('days_employed < 50000'), x = 'days_employed', bins=30,  kde=True)


# В целом, опыт работы до 17500 дней (47 лет), кажется реалистичным. 

# In[12]:


#Зависимость опыта работы от типа деятельности 
df.groupby('income_type')['days_employed'].agg('mean')


# Самые большие значения в стаже у пенсионеров и безработных.  
# Эти данные сложно как-то интерпретировать и  на что-то заменить, необходимо их запросить повторно.    
# Пропуски заполню медианными значениями.   
# Данные по трудовому стажу в исследовании взаимосвязи семейного положения и количества детей на факт погашения кредита в срок не столь необходимы, а тк из 16% от датасэта удалить их нельзя

# In[13]:


#Характеристика дохода 
print(description(df['total_income']))
display(df.nlargest(5, 'total_income'))
display(df.nsmallest(5, 'total_income'))


# На первый взгляд значения дохода реалистичные

# In[14]:


sns.histplot(data=df, x='total_income', bins=30, kde=True)


# В целом, данные без особенностей. Кажется есть немного выбросов

# In[15]:


sns.boxplot(df['total_income'])
print(df.query('total_income > 0.5 * 10**6').count()/len(df))


# Да, все, что больше 0.5 * 10^6  можно назвать выбросами, это всего 1% от датасэта, можно удалить 
# 

# In[16]:


#Зависимость дохода от типа деятельности 
for i in df['income_type'].unique(): 
    print(i, df.loc[df['income_type']==i, 'total_income'].median())


# Логично, что размер дохода зависит от типа деятельности. Заменю пропуски медианным значением для типа деятельности. 

# In[17]:


# Заполним пропуски в столбце с доходом медианным значением для типа дохода
for i in df['income_type'].unique():
    median = df.loc[df['income_type'] == i, 'total_income'].median()
    df.loc[(df['total_income'].isna())&(df['income_type'] == i), 'total_income'] = median
print(df['total_income'].isna().sum())


# In[18]:


# Заполним пропуски в столбце с опытом медианным значением
df['days_employed'] = df['days_employed'].fillna(df['days_employed'].median())
df['days_employed'].isna().sum()


# In[19]:


# Преобразование значений дохода в целочисленный тип 
df['total_income'] = df['total_income'].astype('int')
df['total_income'].dtypes


# In[20]:


#Анализ возраста и количества детей 
for i in ['children', 'dob_years']:
    sns.histplot(data = df, x = i, bins = 30)
    plt.show()
print(df['children'].value_counts())


# В колонке дети есть отрицательное значение, скорее всего это сбой в программе и имелось в виду просто 1 ребенок. Тк таких значений немного, заменю их на 1   
# Есть выброс в виде 20 детей, таких семей единицы в России, думаю, это связано со сбоем, либо неправильным заполнением данных, мб имелось ввиду 2 детей. Таких значений немного (76), заменю их на 2  
# 
# Возраст довольно однороден, похож на нормальное распределение. Есть какие-то младенческие значения, думаю, на уровне выброса 

# In[21]:


# Проверка вохраста на выбросы 
sns.boxplot(df['dob_years'])


# In[22]:


# Замена знаечний 
df = df.replace({'children':{-1:1, 20:2}}) 
# Удаление выбросов 
df = df.query('dob_years > 10 & total_income < 0.5 * 10**6')

for i in ['dob_years', 'total_income']: 
    sns.boxplot(df[i])
    plt.show()


# In[23]:


# Характеристика категориальных значений в датасэте
for i in df.columns: 
    if df[i].dtype == object: 
        print()
        print(i)
        print(df[i].value_counts())


# В колонке пола появилось неожиданное значение XNА, что это значит предположить трудно. Может быть сбой в программе, а может быть так обозначается промежуточный пол, люди бывают разные. Но такое значение всего одно на весь дата-сэт, что не сильно влияет на качество данных.  
# 
# В колонке с образованием одно и то же написано в разном регистре, необходимо привести к одному регистру 
# 
# В целях покупки написано одно и то же, но разными словами 
# 

# In[24]:


#Приведение к одному регистру 
df['education'] = df['education'].str.lower()
df['education'].value_counts()


# In[25]:


# Обработка дубликатов 
print('количество', df.duplicated().sum())
df = df.drop_duplicates().reset_index(drop=True) 
df.duplicated().sum()


# Я думаю, что главная причина появления подобных дубликатов это человеческий фактор и отсутствие конкретных критериев для заполнения полей
# Для поиска и удаления явных дубликатов был использован метод duplicated() и drop_duplicates().reset_index(drop=True) 
# Для поиска неявных дубликатов необходимо было выделить уникальные значения колонки и привести их к одному регистру. 

# In[26]:


df.head()


# #### Итоги предобработки 
# 
# 1. Значение опыта работы из отрицательных привела к положительным
# 2. Заполнила пропуски в опыта работы и доходе медианными значениями. 
# 3. Изменила количество детей: -1 ребенок стал 1Б а 20 детей превратились в 2 
# 4. Удалила выбросы в колонке с возрастом и доходом. 
# 5. Привела значения в образовании к одному регистру 
# 6. Удалила дубликаты 

# ## Обработка данных 

# ### Создание словарей

# In[27]:


#Создание словарей 
education_dict = df[['education_id', 'education']].drop_duplicates().reset_index(drop=True)
family_dict = df[['family_status_id', 'family_status']].drop_duplicates().reset_index(drop=True)
display(education_dict)
display(family_dict)


# In[28]:


df = df.drop(columns = ['education', 'family_status'])
df.head()


# ### Разбиение уровня дохода по категориям 

# In[29]:


# График доходов
sns.distplot(df['total_income'])


# In[30]:


# Разбиение на группы в зависимости от дохода
df['income_category'] = pd.cut(df['total_income'], 5, 
                                labels = ['E, низкий доход', 'D, доход ниже среднего', 'C, средний доход',
                                         'B, доход выше среднего', 'A, высокий доход'])
display(df.groupby('income_category')['total_income'].agg(['mean', 'count']))
df.head()


# ### Разбиение целей по группам 

# In[31]:


df['purpose'].sort_values().unique()


# In[32]:


# Создание и применение функции
def purpose_category(purpose):
    if 'автомобил' in purpose:
        return 'операции с автомобилем'
    if 'образован' in purpose:
        return 'получение образования'
    if 'недвижимост' in purpose:
        return 'операции с недвижимостью'
    if 'жиль' in purpose:
        return 'операции с недвижимостью'
    return 'проведение свадьбы'
df['purpose_category'] = df['purpose'].apply(purpose_category)
display(df.head())
df['purpose_category'].value_counts()


# ## Проверка гипотез 

# ### Влияние количества детей на погашение кредита 

# In[33]:


df.groupby('children')['debt'].agg(['mean', 'sum'])


# Логика такая, что если True == 1 это была задолженность. То если мы все сложим и разделим на общее количество себй (т.е. найдем среднее), то получим процент неуплаты в зависимот от категории 

# Судя по данным, нужно выдавать кредиты семьям, где 5 детей, у них 100%  но выборка очень мала. Потом идут семьи без детей и тремя детьми, а вероятность неуплаты у семей с 1, 2, 4 детьми примерно одинакова. 

# ### Зависимость неуплаты кредита и семейного положения.

# In[34]:


family_dict


# In[35]:


df.groupby('family_status_id')['debt'].agg(['mean', 'sum'])


# Наиболее надежные плательщики это вдовцы, а наиболее часто не возвращают кредиты люди в гражданоском браке и те, кто не состоит в браке. 

# ### Влияние уровня дохода на возвращение кредита в срок.

# In[36]:


df.groupby('income_category')['debt'].agg(['mean', 'sum'])


# Логично, что, чем меньше доход, тем больше вероятность, что будет задолженность по кредиту

# ### Влияние цели кредита на возвращение кредита в срок.

# In[37]:


df.groupby('purpose_category')['debt'].agg(['mean', 'sum'])


# Лучше всего возвращают кредиты, взятые для покупки недвижимости.  

# # Вывод

# В таблице 12 столбцов.
# В столбцах days_employed, total_income имеются пропуски.
# 
# В начальных данных:
# * В данных имелись отрицательные значения в трудовом стаже
# * Были положительные значения большие для изменения трудового стажа в днях ( в 4 строчке 340000 дней = 931 год
# * Пропуски в столбцах days_employed и total_income в одних и тех же строках.
# * В колонке пола было значение XNА.Но такое значение всего одно на весь дата-сэт, что не сильно влияет на качество данных.
# * В колонке с количеством детей тоже были аномальные значения: появились значение с -1 ребенком и с 20 детьми. В России по данным 2017 года число семей с 11 и более детьми составляет 929, поэтому вероятнее, что это данные по семьям, где 2 ребенка. А -1 ребенка довольно сложно предстваить. 
# 
# Отрицательные значения в данных со стажем можно связать с ошибкой в программе.
# 
# Всего строк 21525б, пропущенных значений 2174, доля пропущенных значений 10%
# 
# Орицательные значения в трудовом стаже были приведены к положительным по модулю, пропуски не были заполненные так как данные максимально непонятные. 
# 
# В колонке с данными доходов пропуски были заполнены медианными значениями, чтобы не было сильно влияния очень низких и очень высоких доходов 
# 
# В колонке образования все значения были приведены к регистру, после этого сброшены дубликаты (71), созданы словари к идентификаторам семейного статуса и статуса образования. 
# 
# Значения в колонке с целями из множества были приведены к 4:
#         * операции с недвижимостью    
#         * операции с автомобилем       
#         * получение образования        
#         * проведение свадьбы          
# 
# Заменила количество детей с -1 на 1, с 20 на 2. 
# 
# Влияние разных факторов на погашение кредита в срок:  
#     * Вдовцы реже имебт задолженности по выплате кредита.   
#     * Люди без детей более платежеспособны   
#     * Лучше возвращают кредиты, взятые на недвижимость.   
#     * Чем меньше задолженность, тем меньше вероятность задолженностей
